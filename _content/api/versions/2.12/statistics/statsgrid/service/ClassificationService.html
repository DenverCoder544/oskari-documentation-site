<h1 id="oskaristatisticsstatsgridclassificationservice">Oskari.statistics.statsgrid.ClassificationService</h1>
<p>Used to classifify data. Limits as to how the classification can be done are found in an limits-property of the service:</p>
<pre><code class="language-javascript">limits : {
    count : {
        min : 2,
        max : 9,
        def : 5
    },
    method : [&#39;jenks&#39;, &#39;quantile&#39;, &#39;equal&#39;],
    mode : [&#39;distinct&#39;, &#39;discontinuous&#39;]
}
</code></pre>
<h2 id="functions">Functions</h2>
<h3 id="getclassificationindicatordata-options">getClassification(indicatorData, options)</h3>
<p>Classifies given dataset. Expects data as object like:
 {
    key1 : 1,
    key2 : 3,
    key3 : 2
 }</p>
<p>Options can include:
  {
     count : &lt;number between 2-9 - defaults to 5&gt;,
     method : &lt;one of &#39;jenks&#39;, &#39;quantile&#39;, &#39;equal&#39; - defaults to &#39;jenks&#39;&gt;,
     mode : &lt;one of &#39;distinct&#39;, &#39;discontinuous&#39; - defaults to &#39;distinct&#39;&gt;,
     precission : &lt;undefined or integer between 0-20 - defaults to undefined&gt;
  }</p>
<p>Returns an object like:
 {
      bounds : [&lt;classification bounds as numbers like [0,2,5,6]&gt;],
      ranges : [&lt;classification ranges as strings [&quot;0-2&quot;, &quot;2-5&quot;, &quot;5-6&quot;]&gt;],
      stats : {
          min : <min value in data>,
          max : <max value in data>,
          ...
          mean : <mean value in data>
      },
      getGroups : &lt;function to return keys in data grouped by value ranges, takes an optional param index to get just one group&gt;,
      getIndex : &lt;function to return a group index for data - TODO: is this needed since we have getGroups?&gt;,
      createLegend : &lt;function to create html-legend for ranges, takes colorset and optional title as params&gt;
  }</p>
<pre><code class="language-javascript">var data = {
    key1 : 1,
    key2 : 3,
    key3 : 2
 };
var result = service.getClassification(data, {count : 2});

var groups = result.getGroups(); // returns [[key1, key3], [key2]]
var firstGroup = result.getGroups(0) // returns [key1, key3]
var theseMatch = groups[0] === firstGroup; // true

// using the index, we can get group of keys in the same classification group
var groupIndexForKey2 = result.getIndex(data[key2]) // returns 1
var groupWithKey2 = result.getGroups(groupIndexForKey2) -&gt; returns [key2]
var theseMatchAlso = groups[groupIndexForKey2] === groupWithKey2; // true
</code></pre>
