<h1 id="timeseries">Timeseries</h1>
<ul>
<li>Adds generalized timeseries UI that any other bundle can use with TimeseriesService</li>
<li>Adds support for registering layer animation implementations with TimeseriesLayerService (via TimeseriesService)</li>
<li>Adds implementation for animating WMS layers (via TimeseriesLayerService)</li>
</ul>
<h2 id="screenshot">Screenshot</h2>
<p><img src="/apires/2.13.1/mapping/timeseries/timeseries.png" alt="Timeseries"></p>
<h2 id="description">Description</h2>
<p>Bundles that handle timeseries data/functionality can register with TimeseriesService when they want to show a timeseries control UI. Only one timeseries control UI can be visible at once and TimeseriesService keeps track which one should be visible based on priority. Of different things that can have timeseries UI, layers have the lowest priority.</p>
<p>Bundles that define a new layer type, and which want to support animation, must register a class that will be instantiated for each timeseries enabled layer to implement the animation. This bundle itself registers a animator for &quot;WMS&quot; layers.</p>
<p>Admin can choose different control UI for timeseries enabled layers, and it&#39;s saved in layer options under <code>timeseries</code> entry as:</p>
<pre><code class="language-json">{
  &quot;timeseries&quot;: {
    &quot;ui&quot;: &quot;player|range|none&quot;,
    &quot;metadata&quot;: {
      &quot;layer&quot;: &quot;&lt;metadata layer id&gt;&quot;,
      &quot;attribute&quot;: &quot;&lt;time attribute used to filter metadata layer&gt;&quot;,
      &quot;toggleLevel&quot;: &quot;&lt;map toggle level at which the metadata layer will be shown&gt;&quot;
    }
  }
}
</code></pre>
<p>The metadata is in use when <code>range</code> ui is selected</p>
<h2 id="example---general-case">Example - general case</h2>
<p>Bundle that wants to show timeseries control UI can register with TimeseriesService:</p>
<pre><code class="language-javascript">var timeseriesService = sandbox.getService(&#39;Oskari.mapframework.bundle.timeseries.TimeseriesService&#39;);

var id = &#39;sivcgeu&#39;; // should be unique within &quot;type&quot;
var type = &#39;myTypeOfThing&#39;; // arbitrary type for id
var priority = 23; // priority of registered thing, one with lowest priority across all registred things will be shown UI. Additionally type &quot;layer&quot; has lower priority than all other types
var delegate = ...; // Istance of a class that implements Oskari.mapframework.bundle.timeseries.TimeseriesDelegateProtocol. The UI communicates with your timeseries implementation via the delegate. Each separate &quot;thing&quot; that has timeseries state should have their own delegate instance that is registered to timeseriesService
var conf = {location: &#39;bottom center&#39;}; // configuration given to TimeseriesControlPlugin when it&#39;s created with registered delegate.

timeseriesService.registerTimeseries(id, type, priority, delegate, conf);
</code></pre>
<p>To keep track which registered timeseries is currently active (has UI), for example to check if it&#39;s your bundle&#39;s timeseries:</p>
<pre><code class="language-javascript">timeseriesService.on(&#39;activeChanged&#39;, function (active) {...});
</code></pre>
<p>And when the bundle wants to remove UI from view:</p>
<pre><code class="language-javascript">timeseriesService.unregisterTimeseries(id, type);
</code></pre>
<h2 id="example---new-layer-type">Example - new layer type</h2>
<p>If the bundle wants to add support for timeseries functionality for a certain layer type (AbstractLayer.getLayerType()), it can register a factory function for creating timeseries delegates for that type:</p>
<pre><code class="language-javascript">var timeseriesLayerService = sandbox.getService(&#39;Oskari.mapframework.bundle.timeseries.TimeseriesLayerService&#39;);
timeseriesLayerService.registerLayerType(&#39;&lt;type of layer&gt;&#39;, function(layerId) {
  return ...; // instantiate something implementing Oskari.mapframework.bundle.timeseries.TimeseriesDelegateProtocol and return it
});
</code></pre>
<p>After registering the new type, TimeseriesLayerService will create delegates automatically using the factory function for any layers of the given type that become selected.</p>
<h2 id="bundle-configuration">Bundle configuration</h2>
<p>No configuration is required.</p>
<h2 id="bundle-state">Bundle state</h2>
<pre><code class="language-json">{&quot;time&quot;: [&quot;start time&quot;, &quot;end time&quot;] }
</code></pre>
<p>Currently the bundle state is only recognized by range UI.</p>
<h2 id="requests-the-bundle-sends-out">Requests the bundle sends out</h2>
<table class="table">
  <tr>
    <th> Request </th><th> Where/why it's used</th>
  </tr>
  <tr>
    <td>MapModulePlugin.MapLayerUpdateRequest</td><td> When WMSAnimator changes the current TIME parameter in the WMS url</td>
  </tr>
</table>


<h2 id="events-the-bundle-listens-to">Events the bundle listens to</h2>
<table class="table">
  <tr>
    <th>Event</th><th>Why/when</th>
  </tr>
  <tr>
    <td> MapSizeChangedEvent </td><td> Resize timeseries UI to support different map window sizes </td>
  </tr>
  <tr>
    <td> AfterRearrangeSelectedMapLayerEvent </td><td>Show timeseries UI control for topmost timeseries enabled layer</td>
  </tr>
  <tr>
    <td> AfterMapLayerAddEvent </td><td>Show timeseries UI control for topmost timeseries enabled layer</td>
  </tr>
  <tr>
    <td> AfterMapLayerRemoveEvent </td><td>Show timeseries UI control for topmost timeseries enabled layer</td>
  </tr>
  <tr>
    <td> ProgressEvent </td><td>Track loading status of animating layer</td>
  </tr>
</table>
